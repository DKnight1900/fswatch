package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"syscall"
	"time"

	ignore "github.com/codeskyblue/dockerignore"
	"github.com/codeskyblue/kexec"
	"github.com/howeyc/fsnotify"
	yaml "gopkg.in/yaml.v2"
)

const FWCONFIG = ".fwc.yml"

var signalMaps = map[string]os.Signal{
	"INT":  syscall.SIGINT,
	"HUP":  syscall.SIGHUP,
	"QUIT": syscall.SIGQUIT,
	"TRAP": syscall.SIGTRAP,
	"TERM": syscall.SIGTERM,
	"KILL": syscall.SIGKILL, // kill -9
}

func init() {
	for key, val := range signalMaps {
		signalMaps["SIG"+key] = val
		signalMaps[fmt.Sprintf("%d", val)] = val
	}
}

type TriggerEvent struct {
	Pattens       []string          `yaml:"pattens"`
	Environ       map[string]string `yaml:"env"`
	Command       string            `yaml:"cmd"`
	delayDuration time.Duration     `yaml:"-"`
	Delay         string            `yaml:"delay"`
	Signal        string            `yaml:"signal"`
	killSignal    os.Signal         `yaml:"-"`
	kcmd          *kexec.KCommand
}

func (this *TriggerEvent) Start() error {
	cmd := kexec.CommandString(this.Command)
	env := os.Environ()
	for key, val := range this.Environ {
		env = append(env, fmt.Sprintf("%s=%s", key, val))
	}
	cmd.Env = env
	this.kcmd = cmd
	return cmd.Start()
}

func (this *TriggerEvent) Stop() {
	if this.kcmd != nil {
		this.kcmd.Terminate(os.Interrupt)
		this.kcmd = nil
	}
}

func (this *TriggerEvent) WatchEvent(evtC chan FSEvent, wg *sync.WaitGroup) {
	this.Start()
	for evt := range evtC {
		log.Println(evt)
		this.Stop()
		log.Printf("delay: %v", this.Delay)
		time.Sleep(this.delayDuration)
		this.Start()
	}
	this.Stop()
	wg.Done()
}

type FSEvent struct {
	Name string
}

type FWConfig struct {
	Description string         `yaml:"desc"`
	Triggers    []TriggerEvent `yaml:"triggers"`
	WatchPaths  []string       `yaml:"watch_paths"`
	WatchDepth  int            `yaml:"watch_depth"`

	// Paths     []string `json:"paths"`
	// Depth     int      `json:"depth"`
	// Exclude   []string `json:"exclude"`
	// reExclude []*regexp.Regexp
	// Include   []string `json:"include"`
	// reInclude []*regexp.Regexp
	// bufdur    time.Duration `json:"-"`
	// Command   interface{}   `json:"command"` // can be string or []string
	// cmd       []string
	// Env       map[string]string `json:"env"`

	// AutoRestart     bool          `json:"autorestart"`
	// RestartInterval time.Duration `json:"restart-interval"`
	// KillSignal      string        `json:"kill-signal"`

	// w       *fsnotify.Watcher
	// modtime map[string]time.Time
	// sig     chan string
	// sigOS   chan os.Signal
}

func fixFWConfig(in FWConfig) (out FWConfig, err error) {
	out = in
	for idx, trigger := range in.Triggers {
		outTg := &out.Triggers[idx]
		if trigger.Delay == "" {
			outTg.Delay = "100ms"
		}
		outTg.delayDuration, err = time.ParseDuration(outTg.Delay)
		if err != nil {
			return
		}
		if outTg.Signal == "" {
			outTg.Signal = "HUP"
		}
		outTg.killSignal = signalMaps[outTg.Signal]
	}
	if len(out.WatchPaths) == 0 {
		out.WatchPaths = append(out.WatchPaths, ".")
	}
	if out.WatchDepth == 0 {
		out.WatchDepth = 5
	}
	return
}

func readString(prompt, value string) string {
	fmt.Printf("[?] %s (%s) ", prompt, value)
	var s = value
	fmt.Scanf("%s", &s)
	return s
}

func genFWConfig() FWConfig {
	var (
		name    string
		command string
	)
	cwd, _ := os.Getwd()
	name = filepath.Base(cwd)
	name = readString("name:", name)

	for command == "" {
		command = readString("command:", "go test -v")
	}
	fwc := FWConfig{
		Description: fmt.Sprintf("Auto generated by fswatch [%s]", name),
		Triggers: []TriggerEvent{{
			Pattens: []string{"*.go", "*.c", "*.py"},
			Environ: map[string]string{
				"DEBUG": "1",
			},
			Command: command,
		}},
	}
	out, _ := fixFWConfig(fwc)
	return out
}

func ListAllDir(path string, depth int) (dirs []string, err error) {
	baseNumSeps := strings.Count(path, string(os.PathSeparator))
	err = filepath.Walk(path, func(path string, info os.FileInfo, err error) error {
		if info.IsDir() {
			base := info.Name()
			if base != "." && strings.HasPrefix(base, ".") { // ignore hidden dir
				return filepath.SkipDir
			}

			pathDepth := strings.Count(path, string(os.PathSeparator)) - baseNumSeps
			if pathDepth > depth {
				return filepath.SkipDir
			}
			dirs = append(dirs, path)

			fmt.Println(">>> watch dir: ", path)
		}
		return nil
	})
	return
}

func IsDirectory(path string) bool {
	pinfo, err := os.Stat(path)
	return err == nil && pinfo.IsDir()
}

var fileModifyTimeMap = make(map[string]time.Time)

func IsChanged(path string) bool {
	pinfo, err := os.Stat(path)
	if err != nil {
		return true
	}
	mtime := pinfo.ModTime()
	if mtime.Sub(fileModifyTimeMap[path]) > time.Millisecond*100 { // 100ms
		fileModifyTimeMap[path] = mtime
		return true
	}
	return false
}

func main() {
	dirs, err := ListAllDir(".", 3)
	if err != nil {
		log.Fatal(err)
	}
	fsw, _ := fsnotify.NewWatcher()
	for _, dir := range dirs {
		fsw.Watch(dir)
	}
	for evt := range fsw.Event {
		log.Println(evt)
		if evt.IsCreate() && IsDirectory(evt.Name) {
			log.Println("Add watcher")
			fsw.Watch(evt.Name)
			continue
		}
		if evt.IsDelete() {
			log.Println("Remove watcher")
			fsw.RemoveWatch(evt.Name)
		}
		if IsChanged(evt.Name) {
			log.Printf("IsChanged: %s", evt.Name)
		}

		rd := ioutil.NopCloser(bytes.NewBufferString("*.exe"))
		patterns, err := ignore.ReadIgnore(rd)
		if err != nil {
			log.Fatal(err)
		}

		log.Println(patterns)
	}
	return

	flag.Parse()

	if flag.NArg() == 0 {
		data, err := ioutil.ReadFile(FWCONFIG)
		if err != nil {
			log.Fatal(err)
		}
		fwc := FWConfig{}
		if err = yaml.Unmarshal(data, &fwc); err != nil {
			log.Fatal(err)
		}
		log.Println(string(data))

		// fsw := fsnotify.NewWatcher()
		// fsw.Watch(path)

		evtC := make(chan FSEvent, 1)
		wg := &sync.WaitGroup{}
		for _, tg := range fwc.Triggers {
			wg.Add(1)
			go tg.WatchEvent(evtC, wg)
		}
		evtC <- FSEvent{
			Name: "hello.go",
		}
		time.Sleep(time.Millisecond * 400)
		close(evtC)
		wg.Wait()
		return
	}

	subcmd := flag.Arg(0)

	switch subcmd {
	case "init":
		log.Println("Initial")
		fwc := genFWConfig()
		data, err := yaml.Marshal(fwc)
		if err != nil {
			log.Fatal(err)
		}
		yn := readString(fmt.Sprintf("Save to file (%s)", FWCONFIG), "Y")
		if strings.ToLower(yn) == "y" {
			ioutil.WriteFile(FWCONFIG, data, 0644)
			fmt.Println("Saved!")
		} else {
			fmt.Println(string(data))
		}
	case "start":
		fallthrough
	default:
		log.Println("Unknown:", subcmd)
	}

}
